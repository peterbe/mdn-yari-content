<div>{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Grammar_and_types", "Web/JavaScript/Guide/Loops_and_iteration")}}</div>

<p class="summary">JavaScript підтримує компактний набір інструкцій, зокрема інструкцій для управління потоком, які можна використати, щоб включити інтерактивність до вашого додатку. Цей розділ надає огляд таких інструкцій.</p>

<p><a href="/en-US/docs/Web/JavaScript/Reference/Statements">Довідник JavaScript</a> містить вичерпні дані про інструкції, описані у цьому розділі. Символ крапки з комою (<code>;</code>) розділяє інструкції у JavaScript-коді.</p>

<p>Будь-який вираз у JavaScript також являється інструкцією. Повну інформацію про вирази дивіться у розділі <a href="/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators">Вирази та оператори</a>.</p>

<h2 id="Блокова_інструкція">Блокова інструкція</h2>

<p>Найбільш базовою інструкцією є блокова, що об'єднує декілька інструкцій в одну. Блок обмежується парою фігурних дужок:</p>

<pre class="syntaxbox">{
  інструкція_1;
  інструкція_2;
  .
  .
  .
  інструкція_n;
}
</pre>

<h3 id="Приклад"><strong>Приклад</strong></h3>

<p>Блокова інструкція зазвичай використовується поряд з інструкціями для управління потоком виконання (наприклад, <code>if</code>, <code>for</code>, <code>while</code>).</p>

<pre class="brush: js">while (x &lt; 10) {
  x++;
}
</pre>

<p>У даному випадку, <code>{ x++; }</code> являється блоковою інструкцією.</p>

<p><strong>Важливо</strong>: JavaScript до ECMAScript2015 не має блокової області видимості. Змінні, об'явлені всередині блоку прив'язуються до області меж зовнішньої функції, або ж усього скрипта. І ефект від їх задання поширюється за межі блоку. Інакше кажучи, блокові інструкції не задають області видимості. "Поодинокі" блоки у JavaScript можуть призвести до абсолютно відмінних результатів від аналогічного коду на C чи Java. Наприклад:</p>

<pre class="brush: js">var x = 1;
{
  var x = 2;
}
console.log(x); // в результаті - 2
</pre>

<p>В результаті отримуємо 2 тому, що інструкція <code>var x</code> всередині блоку знаходиться в одній області видимості з інструкцією <code>var x</code> перед блоком. У C чи Java такий подібний код поверне 1.</p>

<p>Починаючи з ECMAScript2015, декларації змінних <code>let</code> і <code>const</code> мають блокову область видимості. Докладніше на довідкових сторінках {{jsxref("Statements/let", "let")}} і {{jsxref("Statements/const", "const")}}.</p>

<h2 id="Умовні_інструкції">Умовні інструкції</h2>

<p>Умовною інструкцією називається набір команд, що виконаються якщо певна умова буде істинною. JavaScript підтримує два види умовних інструкцій: <code>if...else</code> та <code>switch</code>.</p>

<h3 id="Інструкція_if...else">Інструкція <code>if...else</code></h3>

<p>Використовуйте <code>if</code>, щоб виконати інструкцію, якщо логічна умова являється істинною. Використовуйте необов'яковий <code>else</code>, щоб виконати інструкцію, якщо умова являється хибною. Інструкція <code>if</code> виглядає так:</p>

<pre class="syntaxbox">if (умова) {
  інструкція_1;
} else {
  інструкція_2;
}</pre>

<p>Тут <code>умова</code> може бути будь-яким виразом, що зводиться до <code>true</code> чи <code>false</code> (дивіться розділ <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean#Description">Boolean</a> для роз'яснення, що і як обчислюється до <code>true</code> чи <code>false</code>). Якщо <code>умова</code> обчислюється до <code>true</code>, виконується <code>інструкція_1</code>; інакше виконується <code>інструкція_2</code>. <code>інструкція_1</code> та <code>інструкція_2</code> можуть бути будь-якими, включаючи вкладені інструкції <code>if</code>.</p>

<p>Можна також суміщувати інструкції у вигляді <code>else if</code>, щоб послідовно перевірити декілька умов, як-от, наприклад:</p>

<pre class="syntaxbox">if (умова_1) {
  інструкція_1;
} else if (умова_2) {
  інструкція_2;
} else if (умова_n) {
  інструкція_n;
} else {
  інструкція_остання;
} 
</pre>

<p>У випадку наявності декількох таких умов буде виконано лише найперший обчислений до <code>true</code>. Щоб виконати декілька інструкцій, слід об'єднати їх у блок (<code>{ ... }</code>) . Загалом, хорошою практикою вважається завжди використовувати блоки інструкцій, особливо при вкладенні інструкцій <code>if</code>:</p>

<pre class="syntaxbox">if (умова) {
  інструкція_1_виконується_якщо_умова_вірна;
  інструкція_2_виконується_якщо_умова_вірна;
} else {
  інструкція_3_виконується_якщо_умова_невірна;
  інструкція_4_виконується_якщо_умова_невірна;
}
</pre>

<div>Не рекомендується використовувати звичайні присвоєння в умовних виразах, так як присвоєння можна сплутати з порівнянням при перегляді коді. Наприклад, не слід писати ось так:</div>

<pre class="example-bad brush: js">if (x = y) {
  /* statements here */
}
</pre>

<p>Якщо все ж таки потрібно використати присвоєння всередині умовного виразу, загальною практикою є додавання зайвих дужок навколо присвоєння, як-от:</p>

<pre class="brush: js">if ((x = y)) {
  /* якісь інструкції */
}
</pre>

<h4 id="Хибні_значення">Хибні значення</h4>

<p>Наступні значення обчислюються до <code>false</code> (також знані як {{Glossary("Falsy")}} значення):</p>

<ul>
 <li><code>false</code></li>
 <li><code>undefined</code></li>
 <li><code>null</code></li>
 <li><code>0</code></li>
 <li><code>NaN</code></li>
 <li>порожня стрічка (<code>""</code>)</li>
</ul>

<p>Всі інші значення (включно з усіма об'єктами), обчислюються до <code>true</code> при передачі в умовний вираз.</p>

<p>Не плутайте примітивні булеві значення <code>true</code> та <code>false</code> із істинними і хибними значеннями об'єкту {{jsxref("Boolean")}}. Наприклад:</p>

<pre class="brush: js">var b = new Boolean(false);
if (b) // цей умовний вираз буде істинним
if (b == true) // цей умовний вираз буде хибним
</pre>

<h4 id="Приклад_2"><strong>Приклад</strong></h4>

<p>У наведеному далі прикладі функція <code>checkData</code> повертає <code>true</code>, якщо у об'єкті  <code>Text</code> три символи, а інакше вона показує сповіщення та повертає <code>false</code>.</p>

<pre class="brush: js">function checkData() {
  if (document.form1.threeChar.value.length == 3) {
    return true;
  } else {
    alert('Enter exactly three characters. ' +
    document.form1.threeChar.value + ' is not valid.');
    return false;
  }
}
</pre>

<h3 id="switch_statement"><code>switch</code> statement</h3>

<p>A <code>switch</code> statement allows a program to evaluate an expression and attempt to match the expression's value to a case label. If a match is found, the program executes the associated statement. A <code>switch</code> statement looks as follows:</p>

<pre class="syntaxbox">switch (expression) {
  case label_1:
    statements_1
    [break;]
  case label_2:
    statements_2
    [break;]
    ...
  default:
    statements_def
    [break;]
}
</pre>

<p>The program first looks for a <code>case</code> clause with a label matching the value of expression and then transfers control to that clause, executing the associated statements. If no matching label is found, the program looks for the optional <code>default</code> clause, and if found, transfers control to that clause, executing the associated statements. If no <code>default</code> clause is found, the program continues execution at the statement following the end of <code>switch</code>. By convention, the <code>default</code> clause is the last clause, but it does not need to be so.</p>

<p>The optional <code>break</code> statement associated with each <code>case</code> clause ensures that the program breaks out of <code>switch</code> once the matched statement is executed and continues execution at the statement following switch. If <code>break</code> is omitted, the program continues execution at the next statement in the <code>switch</code> statement.</p>

<h4 id="Example"><strong>Example</strong></h4>

<p>In the following example, if <code>fruittype</code> evaluates to "Bananas", the program matches the value with case "Bananas" and executes the associated statement. When <code>break</code> is encountered, the program terminates <code>switch</code> and executes the statement following <code>switch</code>. If <code>break</code> were omitted, the statement for case "Cherries" would also be executed.</p>

<pre class="brush: js">switch (fruittype) {
  case 'Oranges':
    console.log('Oranges are $0.59 a pound.');
    break;
  case 'Apples':
    console.log('Apples are $0.32 a pound.');
    break;
  case 'Bananas':
    console.log('Bananas are $0.48 a pound.');
    break;
  case 'Cherries':
    console.log('Cherries are $3.00 a pound.');
    break;
  case 'Mangoes':
    console.log('Mangoes are $0.56 a pound.');
    break;
  case 'Papayas':
    console.log('Mangoes and papayas are $2.79 a pound.');
    break;
  default:
   console.log('Sorry, we are out of ' + fruittype + '.');
}
console.log("Is there anything else you'd like?");</pre>

<h2 id="Exception_handling_statements">Exception handling statements</h2>

<p>You can throw exceptions using the <code>throw</code> statement and handle them using the <code>try...catch</code> statements.</p>

<ul>
 <li><a href="#throw_statement"><code>throw</code> statement</a></li>
 <li><a href="#try...catch_statement"><code>try...catch</code> statement</a></li>
</ul>

<h3 id="Exception_types">Exception types</h3>

<p>Just about any object can be thrown in JavaScript. Nevertheless, not all thrown objects are created equal. While it is fairly common to throw numbers or strings as errors it is frequently more effective to use one of the exception types specifically created for this purpose:зроблений ленд, зроблені декілька екранів? чи прям все включаючи адаптив?</p>

<ul>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types">ECMAScript exceptions</a></li>
 <li>{{domxref("DOMException")}} and {{domxref("DOMError")}}</li>
</ul>

<h3 id="оператор_throw">оператор <code>throw</code></h3>

<p>Скористайтеся оператором <code>throw</code>, щоб викинути виняток. Коли викидаєте виняток, ви вказуєте вираз, що містить значення, яке викидається:</p>

<pre class="syntaxbox">throw expression;
</pre>

<p>Ви можете викинути будь-який вираз, не тільки вирази окремих типів. Наступний код викидає кілька винятків різних типів:</p>

<pre class="brush: js">throw 'Error2';   // тип String
throw 42;         // тип Number
throw true;       // тип Boolean
throw {toString: function() { return "Я об'єкт!"; } };
</pre>

<div class="note"><strong>Примітка:</strong> Ви можете вказати об'єкт, коли викидаєте виняток. Після цього ви можете звертатися до властивостей об'єкта у блоці <code>catch</code>.</div>

<pre class="brush: js">// Створити об'єкт UserException
function UserException(message) {
  this.message = message;
  this.name = 'UserException';
}

// Перетворити виняток у гарний рядок при використанні в якості рядка
// (наприклад, у консолі помилок)
UserException.prototype.toString = function() {
  return this.name + ': "' + this.message + '"';
}

// Створити екземпляр об'єкта та викинути його
throw new UserException('Значення завелике');</pre>

<h3 id="try...catch_statement"><code>try...catch</code> statement</h3>

<p>The <code>try...catch</code> statement marks a block of statements to try, and specifies one or more responses should an exception be thrown. If an exception is thrown, the <code>try...catch</code> statement catches it.</p>

<p>The <code>try...catch</code> statement consists of a <code>try</code> block, which contains one or more statements, and a <code>catch</code> block, containing statements that specify what to do if an exception is thrown in the <code>try</code> block. That is, you want the <code>try</code> block to succeed, and if it does not succeed, you want control to pass to the <code>catch</code> block. If any statement within the <code>try</code> block (or in a function called from within the <code>try</code> block) throws an exception, control immediately shifts to the <code>catch</code> block. If no exception is thrown in the <code>try</code> block, the <code>catch</code> block is skipped. The <code>finally</code> block executes after the <code>try</code> and <code>catch</code> blocks execute but before the statements following the <code>try...catch</code> statement.</p>

<p>The following example uses a <code>try...catch</code> statement. The example calls a function that retrieves a month name from an array based on the value passed to the function. If the value does not correspond to a month number (1-12), an exception is thrown with the value <code>"InvalidMonthNo"</code> and the statements in the <code>catch</code> block set the <code>monthName</code> variable to <code>unknown</code>.</p>

<pre class="brush: js">function getMonthName(mo) {
  mo = mo - 1; // Adjust month number for array index (1 = Jan, 12 = Dec)
  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
                'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  if (months[mo]) {
    return months[mo];
  } else {
    throw 'InvalidMonthNo'; //throw keyword is used here
  }
}

try { // statements to try
  monthName = getMonthName(myMonth); // function could throw exception
}
catch (e) {
  monthName = 'unknown';
  logMyErrors(e); // pass exception object to error handler -&gt; your own function
}
</pre>

<h4 id="The_catch_block">The <code>catch</code> block</h4>

<p>You can use a <code>catch</code> block to handle all exceptions that may be generated in the <code>try</code> block.</p>

<pre class="syntaxbox">catch (catchID) {
  statements
}
</pre>

<p>The <code>catch</code> block specifies an identifier (<code>catchID</code> in the preceding syntax) that holds the value specified by the <code>throw</code> statement; you can use this identifier to get information about the exception that was thrown. JavaScript creates this identifier when the <code>catch</code> block is entered; the identifier lasts only for the duration of the <code>catch</code> block; after the <code>catch</code> block finishes executing, the identifier is no longer available.</p>

<p>For example, the following code throws an exception. When the exception occurs, control transfers to the <code>catch</code> block.</p>

<pre class="brush: js">try {
  throw 'myException'; // generates an exception
}
catch (e) {
  // statements to handle any exceptions
  logMyErrors(e); // pass exception object to error handler
}
</pre>

<h4 id="The_finally_block">The <code>finally</code> block</h4>

<p>The <code>finally</code> block contains statements to execute after the <code>try</code> and <code>catch</code> blocks execute but before the statements following the <code>try...catch</code> statement. The <code>finally</code> block executes whether or not an exception is thrown. If an exception is thrown, the statements in the <code>finally</code> block execute even if no <code>catch</code> block handles the exception.</p>

<p>You can use the <code>finally</code> block to make your script fail gracefully when an exception occurs; for example, you may need to release a resource that your script has tied up. The following example opens a file and then executes statements that use the file (server-side JavaScript allows you to access files). If an exception is thrown while the file is open, the <code>finally</code> block closes the file before the script fails.</p>

<pre class="brush: js">openMyFile();
try {
  writeMyFile(theData); //This may throw an error
} catch(e) {  
  handleError(e); // If we got an error we handle it
} finally {
  closeMyFile(); // always close the resource
}
</pre>

<p>If the <code>finally</code> block returns a value, this value becomes the return value of the entire <code>try-catch-finally</code> production, regardless of any <code>return</code> statements in the <code>try</code> and <code>catch</code> blocks:</p>

<pre class="brush: js">function f() {
  try {
    console.log(0);
    throw 'bogus';
  } catch(e) {
    console.log(1);
    return true; // this return statement is suspended
                 // until finally block has completed
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    console.log(4); // not reachable
  }
  // "return false" is executed now  
  console.log(5); // not reachable
}
f(); // console 0, 1, 3; returns false
</pre>

<p>Overwriting of return values by the <code>finally</code> block also applies to exceptions thrown or re-thrown inside of the <code>catch</code> block:</p>

<pre class="brush: js">function f() {
  try {
    throw 'bogus';
  } catch(e) {
    console.log('caught inner "bogus"');
    throw e; // this throw statement is suspended until 
             // finally block has completed
  } finally {
    return false; // overwrites the previous "throw"
  }
  // "return false" is executed now
}

try {
  f();
} catch(e) {
  // this is never reached because the throw inside
  // the catch is overwritten
  // by the return in finally
  console.log('caught outer "bogus"');
}

// OUTPUT
// caught inner "bogus"</pre>

<h4 id="Nesting_try...catch_statements">Nesting try...catch statements</h4>

<p>You can nest one or more <code>try...catch</code> statements. If an inner <code>try...catch</code> statement does not have a <code>catch</code> block, it needs to have a <code>finally</code> block and the enclosing <code>try...catch</code> statement's <code>catch</code> block is checked for a match. For more information, see <a href="/en-US/docs/Web/JavaScript/Reference/Statements/try...catch#Nested_try-blocks">nested try-blocks</a> on the <code><a href="/en-US/docs/Web/JavaScript/Reference/Statements/try...catch">try...catch</a></code> reference page.</p>

<h3 id="Utilizing_Error_objects">Utilizing <code>Error</code> objects</h3>

<p>Depending on the type of error, you may be able to use the 'name' and 'message' properties to get a more refined message. 'name' provides the general class of Error (e.g., 'DOMException' or 'Error'), while 'message' generally provides a more succinct message than one would get by converting the error object to a string.</p>

<p>If you are throwing your own exceptions, in order to take advantage of these properties (such as if your catch block doesn't discriminate between your own exceptions and system ones), you can use the Error constructor. For example:</p>

<pre class="brush: js">function doSomethingErrorProne() {
  if (ourCodeMakesAMistake()) {
    throw (new Error('The message'));
  } else {
    doSomethingToGetAJavascriptError();
  }
}
....
try {
  doSomethingErrorProne();
} catch (e) {
  console.log(e.name); // logs 'Error'
  console.log(e.message); // logs 'The message' or a JavaScript error message)
}</pre>

<h2 id="Promises">Promises</h2>

<p>Starting with ECMAScript2015, JavaScript gains support for {{jsxref("Promise")}} objects allowing you to control the flow of deferred and asynchronous operations.</p>

<p>A <code>Promise</code> is in one of these states:</p>

<ul>
 <li><em>pending</em>: initial state, not fulfilled or rejected.</li>
 <li><em>fulfilled</em>: successful operation</li>
 <li><em>rejected</em>: failed operation.</li>
 <li><em>settled</em>: the Promise is either fulfilled or rejected, but not pending.</li>
</ul>

<p><img alt="" src="https://mdn.mozillademos.org/files/8633/promises.png" style="height: 297px; width: 801px;"></p>

<h3 id="Loading_an_image_with_XHR">Loading an image with XHR</h3>

<p>A simple example using <code>Promise</code> and <code><a href="/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></code> to load an image is available at the MDN GitHub<a href="https://github.com/mdn/js-examples/tree/master/promises-test"> js-examples</a> repository. You can also <a href="https://mdn.github.io/js-examples/promises-test/">see it in action</a>. Each step is commented and allows you to follow the Promise and XHR architecture closely. Here is the uncommented version, showing the <code>Promise</code> flow so that you can get an idea:</p>

<pre class="brush: js">function imgLoad(url) {
  return new Promise(function(resolve, reject) {
    var request = new XMLHttpRequest();
    request.open('GET', url);
    request.responseType = 'blob';
    request.onload = function() {
      if (request.status === 200) {
        resolve(request.response);
      } else {
        reject(Error('Image didn\'t load successfully; error code:' 
                     + request.statusText));
      }
    };
    request.onerror = function() {
      reject(Error('There was a network error.'));
    };
    request.send();
  });
}</pre>

<p>For more detailed information, see the {{jsxref("Promise")}} reference page and the <a href="/en-US/docs/Web/JavaScript/Guide/Using_promises">Using Promises</a> guide.</p>

<div>{{PreviousNext("Web/JavaScript/Guide/Grammar_and_types", "Web/JavaScript/Guide/Loops_and_iteration")}}</div>