<p>{{WebGLSidebar}}</p>

<p>Cet article fournit des suggestions et des conseils vous permettant d'améliorer votre contenu WebGL. Suivre ces suggestions vous permettra d'améliorer la compatibilité de votre application web avec plus de périphériques et de navigateurs et d'optimiser ses performances.</p>

<h2 id="Choses_à_éviter">Choses à éviter</h2>

<ul>
 <li>Assurez-vous toujours que votre application fonctionne sans générer d'erreurs WebGL, retournées par <code>getError()</code>. Dans Firefox, toutes les erreurs WebGL (jusqu'à une certaine limite) et certains problèmes issus de WebGL sont signalés comme avertissements Javascript ainsi qu'un message de description. Vous ne voulez pas que votre app vomisse dans la console utilisateur ? Évidemment que non.</li>
 <li>N'utilisez pas <code>#ifdef GL_ES</code> dans vos shaders WebGL; bien que certains exemples l'aient utilisé, ce n'est plus nécessaire puisque cette condition est toujours vraie dans les shaders WebGL.</li>
 <li>Using <code>highp</code> precision in fragment shaders will prevent your content from working on some older mobile hardware. You can use <code>mediump</code> instead, but be aware that this often results in corrupted rendering due to lack of precision on most mobile devices, and the corruption is not going to be visible on a typical desktop computer. In general, only using <code>highp</code> in both vertex and fragment shaders is safer unless shaders are thoroughly tested on a variety of platforms. Starting in Firefox 11, the WebGL <code>getShaderPrecisionFormat()</code> function is implemented, allowing you to check if <code>highp</code> precision is supported, and more generally letting you query the actual precision of all supported precision qualifiers.</li>
</ul>

<h2 id="Things_to_keep_in_mind">Things to keep in mind</h2>

<ul>
 <li>Some WebGL capabilities depend on the client. Before relying on them, you should use the WebGL <code>getParameter()</code> function to determine what values are supported on the client. For example, the maximum size of a 2D texture is given by <code>webgl.getParameter(webgl.MAX_TEXTURE_SIZE)</code>. Starting in Firefox 10, the <code>webgl.min_capability_mode</code> preference allows simulating minimal values for these capabilities, to test portability.</li>
 <li>In particular, note that usage of textures in vertex shaders is only possible if <code>webgl.getParameter(webgl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)</code> is greater than zero. Typically, this fails on current mobile hardware.</li>
 <li>The availability of most WebGL extensions depends on the client. When using WebGL extensions, if possible, try to make them optional by gracefully adapting to the case there they are not supported. Starting in Firefox 10, the <code>webgl.disable-extensions</code> preference allows simulating the absence of all extensions, to test portability.</li>
 <li>Rendering to a floating-point texture may not be supported, even if the <code>OES_texture_float</code> extension is supported. Typically, this fails on current mobile hardware. To check if this is supported, you have to call the WebGL <code>checkFramebufferStatus()</code> function.</li>
 <li>Rendering to a canvas can be done at a different resolution than the style sheet will eventually force the canvas to appear at. If struggling with performance you should consider rendering to a low resolution WebGL context and using CSS to upscale its canvas to the size you intend.</li>
</ul>

<h2 id="Conseils_de_performance_généraux">Conseils de performance généraux</h2>

<ul>
 <li>Tout ce qui requiert une synchronisation entre le CPU et le GPU est potentiellement très lent, donc évitez si possible de le faire dans vos boucles principales de rendering. Ceci inclut les appels WebGL suivants : <code>getError()</code>, <code>readPixels()</code>, et <code>finish()</code>. Les appels getter WebGL comme <code>getParameter()</code> et <code>getUniformLocation()</code> doivent également être considérés comme lents, donc efforcez-vous de mettre leurs résultats en cache dans une variable JavaScript.</li>
 <li>Fewer, larger draw operations will improve performance. If you have 1000 sprites to paint, try to do it as a single <code>drawArrays()</code> or <code>drawElements()</code> call. You can draw degenerate (flat) triangles if you need to draw discontinuous objects as a single <code>drawArrays()</code> call.</li>
 <li>Fewer state changes will also improve performance. In particular, if you can pack multiple images into a single texture and select them by using the appropriate texture coordinates, that can help you do fewer texture binding changes, which improves performance.
  <ul>
   <li>In some rare cases, packing greyscale textures which belong together into the color channels of a single texture might help.</li>
  </ul>
 </li>
 <li>Smaller textures perform better than larger ones. For this reason, mipmapping can be a performance win.</li>
 <li>Simpler shaders perform better than complex ones. In particular, if you can remove an <code>if</code> statement from a shader, that will make it run faster. Division and math functions like <code>log()</code> should be considered expensive too.
  <ul>
   <li>However, nowadays even mobile devices possess powerful GPUs that are capable of running even relatively complex shader programs. Moreover, because shaders are compiled, the eventual machine code that actually runs on the hardware may be highly optimized. What may seem like an expensive function call may in fact compile into only few (or even a single) machine instructions. This is particularly true for {{Glossary("GLSL")}} functions that typically operate on vectors, such as <code>normalize()</code>, <code>dot()</code> and <code>mix()</code>. The best advice in that regard is to use the built-in functions, rather than try to implement, for example, one's own version of a dot-product or linear interpolation, which may in fact compile to larger and less optimized machine code. Finally, it is important to keep in mind that GPUs are constructed to do complex mathematical calculations in hardware, and therefore, may support math functions, such as <code>sin()</code>, <code>cos()</code> and other, through dedicated machine instructions.</li>
  </ul>
 </li>
 <li>Do as much as you can in the vertex shader, rather than in the fragment shader. Because, per rendering pass, fragment shaders run many more times than vertex shaders, any calculation that can be done on the vertices and then just interpolated among fragments is a performance boon (this interpolation is done "automagically" for you, through the fixed functionality rasterization phase of the OpenGL pipeline). For example, a simple animation of a textured surface can be achieved through a time-dependent transformation of texture coordinates (simplest case is to add a uniform vector to the texture coordinates attribute vector). If visually acceptable, one can transform the texture coordinates in the vertex shader rather than in the fragment shader, to get better performance.</li>
 <li>Always have vertex attrib 0 array enabled. If you draw with vertex attrib 0 array disabled, you will force the browser to do complicated emulation when running on desktop OpenGL (e.g. on Mac OSX). This is because in desktop OpenGL, nothing gets drawn if vertex attrib 0 is not array-enabled. You can use <code>bindAttribLocation()</code> to force a vertex attribute to use location <code>0</code>, and use <code>enableVertexAttribArray()</code> to make it array-enabled.</li>
</ul>